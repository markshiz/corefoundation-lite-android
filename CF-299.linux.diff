diff -r -u CF-299.orig/AppServices.subproj/CFUserNotification.c CF-299/AppServices.subproj/CFUserNotification.c
--- CF-299.orig/AppServices.subproj/CFUserNotification.c	2003-10-24 15:23:55.000000000 -0700
+++ CF-299/AppServices.subproj/CFUserNotification.c	2005-02-24 17:47:53.221720208 -0800
@@ -78,7 +78,9 @@
     CFOptionFlags _responseFlags;
     CFStringRef _sessionID;
     CFDictionaryRef _responseDictionary;
+#if defined(__MACH__)
     CFMachPortRef _machPort;
+#endif
     CFUserNotificationCallBack _callout;
 };
 
@@ -122,6 +124,8 @@
 
 #endif /* __MACH__ */
 
+static void __CFUserNotificationDeallocate(CFTypeRef cf);
+
 static const CFRuntimeClass __CFUserNotificationClass = {
     0,
     "CFUserNotification",
diff -r -u CF-299.orig/Base.subproj/CFBase.c CF-299/Base.subproj/CFBase.c
--- CF-299.orig/Base.subproj/CFBase.c	2003-10-24 15:23:55.000000000 -0700
+++ CF-299/Base.subproj/CFBase.c	2005-02-24 17:49:14.579351968 -0800
@@ -399,7 +399,9 @@
     __kCFAllocatorSystemDefault._context.info = malloc_default_zone();
 #endif
     __kCFAllocatorSystemDefault._allocator = kCFAllocatorSystemDefault;
+#if defined(__MACH__)
     memset(malloc_default_zone(), 0, 8);
+#endif
 
     _CFRuntimeSetInstanceTypeID(&__kCFAllocatorMalloc, __kCFAllocatorTypeID);
     __kCFAllocatorMalloc._base._isa = __CFISAForTypeID(__kCFAllocatorTypeID);
diff -r -u CF-299.orig/Base.subproj/CFInternal.h CF-299/Base.subproj/CFInternal.h
--- CF-299.orig/Base.subproj/CFInternal.h	2003-10-24 15:23:55.000000000 -0700
+++ CF-299/Base.subproj/CFInternal.h	2005-02-24 18:36:34.375637312 -0800
@@ -72,7 +72,9 @@
 
 CF_EXPORT void __CFSetNastyFile(CFTypeRef cf);
 
+#if defined(__MACH__)
 CF_EXPORT void _CFMachPortInstallNotifyPort(CFRunLoopRef rl, CFStringRef mode);
+#endif
 
 
 #if defined(__ppc__)
@@ -231,7 +233,30 @@
 extern Boolean __CFStringScanHex(CFStringInlineBuffer *buf, SInt32 *indexPtr, unsigned *result);
 
 
+#ifdef __MACH__
 #define CONST_STRING_DECL(S, V) const CFStringRef S = __builtin___CFStringMakeConstantString(V);
+#else
+
+struct CF_CONST_STRING {
+    CFRuntimeBase _base;
+    uint8_t *_ptr;
+    uint32_t _length;
+};
+
+extern int __CFConstantStringClassReference[];
+
+#if defined(__ppc__)
+#define CONST_STRING_DECL(S, V)			\
+static struct CF_CONST_STRING __ ## S ## __ = {{&__CFConstantStringClassReference, 0x0000, 0x07c8}, V, sizeof(V) - 1}; \
+const CFStringRef S = (CFStringRef) & __ ## S ## __;
+#elif defined(__i386__)
+#define CONST_STRING_DECL(S, V)			\
+static struct CF_CONST_STRING __ ## S ## __ = {{&__CFConstantStringClassReference, 0x07c8, 0x0000}, V, sizeof(V) - 1}; \
+const CFStringRef S = (CFStringRef) & __ ## S ## __;
+#else
+#error undefined architecture
+#endif
+#endif
 
 
 #if defined(__MACH__)
@@ -379,6 +404,8 @@
 #define __CFISAForTypeID(x) (NULL)
 #endif
 
+#define __CFMaxRuntimeTypes	256
+
 #if defined(__MACH__)
 
 struct objc_class {     // nasty, nasty
@@ -386,8 +413,6 @@
         const char *name;
         long __fields1__[7];
 };
-
-#define __CFMaxRuntimeTypes	256
 	
 extern struct objc_class *__CFRuntimeObjCClassTable[];
 CF_INLINE void *__CFISAForTypeID(CFTypeID typeID) {
diff -r -u CF-299.orig/Base.subproj/CFPlatform.c CF-299/Base.subproj/CFPlatform.c
--- CF-299.orig/Base.subproj/CFPlatform.c	2003-10-24 15:23:55.000000000 -0700
+++ CF-299/Base.subproj/CFPlatform.c	2005-02-24 17:59:40.821148744 -0800
@@ -134,6 +134,7 @@
 }
 
 const char *_CFProcessPath(void) {
+#if !defined(__LINUX__)
     CFAllocatorRef alloc = NULL;
     char *thePath = NULL;
     int execIndex = 0;
@@ -254,6 +255,7 @@
 		__CFprogname = __CFProcessPath;
 	}
     }
+#endif
     if (!__CFProcessPath) {
 	__CFProcessPath = "";
     }
diff -r -u CF-299.orig/Base.subproj/CFRuntime.c CF-299/Base.subproj/CFRuntime.c
--- CF-299.orig/Base.subproj/CFRuntime.c	2003-10-24 15:23:55.000000000 -0700
+++ CF-299/Base.subproj/CFRuntime.c	2005-02-24 18:30:03.577047728 -0800
@@ -110,7 +110,11 @@
 }
 #endif
 
+#if defined(__MACH__)
 extern void __HALT(void);
+#else
+#define __HALT abort
+#endif
 
 static CFTypeID __kCFNotATypeTypeID = _kCFRuntimeNotATypeID;
 
@@ -637,7 +641,9 @@
 	__done = 1;
 	SYSCALL_TRACE(0xC000);
 
+#if defined(__MACH__)
 	__setonlyClocaleconv(1);
+#endif
 #if defined(DEBUG)
 	{
 	    const char *value = getenv("CFZombieLevel");
diff -r -u CF-299.orig/Base.subproj/CFUtilities.h CF-299/Base.subproj/CFUtilities.h
--- CF-299.orig/Base.subproj/CFUtilities.h	2003-10-24 15:23:55.000000000 -0700
+++ CF-299/Base.subproj/CFUtilities.h	2005-02-24 18:26:36.426539392 -0800
@@ -53,6 +53,8 @@
 /* _CFExecutableLinkedOnOrAfter(releaseVersionName) will return YES if the current executable seems to be linked on or after the specified release. Example: If you specify CFSystemVersionPuma (10.1), you will get back true for executables linked on Puma or Jaguar(10.2), but false for those linked on Cheetah (10.0) or any of its software updates (10.0.x). You will also get back false for any app whose version info could not be figured out.
     This function caches its results, so no need to cache at call sites.
 */
+#endif /* __MACH__ */
+
 typedef enum {
     CFSystemVersionCheetah = 0,		/* 10.0 */
     CFSystemVersionPuma = 1,		/* 10.1 */
@@ -63,9 +65,11 @@
     CFSystemVersionMax			/* This should bump up when new entries are added */
 } CFSystemVersion;
 
+#if defined(__MACH__)
 CF_EXPORT Boolean _CFExecutableLinkedOnOrAfter(CFSystemVersion version);
-    
-#endif /* __MACH__ */
+#else
+#define _CFExecutableLinkedOnOrAfter(a) (1)
+#endif
 
 
 #if defined(__cplusplus)
diff -r -u CF-299.orig/Collections.subproj/CFDictionary.c CF-299/Collections.subproj/CFDictionary.c
--- CF-299.orig/Collections.subproj/CFDictionary.c	2003-10-24 15:23:55.000000000 -0700
+++ CF-299/Collections.subproj/CFDictionary.c	2005-02-24 18:07:08.157143336 -0800
@@ -184,8 +184,8 @@
 
 #if !defined(__MACH__)
 
-#define CF_OBJC_KVO_WILLCHANGE(obj, sel, a1)
-#define CF_OBJC_KVO_DIDCHANGE(obj, sel, a1)
+#define CF_OBJC_KVO_WILLCHANGE(obj, key)
+#define CF_OBJC_KVO_DIDCHANGE(obj, key)
 
 #else
 
diff -r -u CF-299.orig/Makefile CF-299/Makefile
--- CF-299.orig/Makefile	2003-10-15 10:30:00.000000000 -0700
+++ CF-299/Makefile	2005-02-24 17:37:32.090146560 -0800
@@ -35,7 +35,7 @@
 endif
 
 ifeq "$(PLATFORM)" "Linux"
-PLATFORM_CFLAGS = -D__LINUX__=1
+PLATFORM_CFLAGS = -D__LINUX__=1 -D__STDC_VERSION__=199901L
 endif
 
 ifeq "$(PLATFORM)" "FreeBSD"
diff -r -u CF-299.orig/PlugIn.subproj/CFBundle.c CF-299/PlugIn.subproj/CFBundle.c
--- CF-299.orig/PlugIn.subproj/CFBundle.c	2003-10-24 15:23:55.000000000 -0700
+++ CF-299/PlugIn.subproj/CFBundle.c	2005-02-24 18:08:43.162700296 -0800
@@ -37,6 +37,7 @@
 #include "CFPriv.h"
 #include <CoreFoundation/CFByteOrder.h>
 #include "CFBundle_BinaryTypes.h"
+#include <unistd.h>
 
 #if defined(BINARY_SUPPORT_DYLD)
 // Import the mach-o headers that define the macho magic numbers
diff -r -u CF-299.orig/PlugIn.subproj/CFBundle_Internal.h CF-299/PlugIn.subproj/CFBundle_Internal.h
--- CF-299.orig/PlugIn.subproj/CFBundle_Internal.h	2003-10-24 15:23:55.000000000 -0700
+++ CF-299/PlugIn.subproj/CFBundle_Internal.h	2005-02-24 18:07:54.351120784 -0800
@@ -134,7 +134,7 @@
 extern Boolean _CFBundleDLLLoad(CFBundleRef bundle);
 extern void _CFBundleDLLUnload(CFBundleRef bundle);
 extern void *_CFBundleDLLGetSymbolByName(CFBundleRef bundle, CFStringRef symbolName);
-#endif BINARY_SUPPORT_DLL
+#endif /* BINARY_SUPPORT_DLL */
 
 
 /* Private PlugIn-related CFBundle API */
diff -r -u CF-299.orig/String.subproj/CFString.c CF-299/String.subproj/CFString.c
--- CF-299.orig/String.subproj/CFString.c	2003-10-24 15:23:55.000000000 -0700
+++ CF-299/String.subproj/CFString.c	2005-02-24 18:23:59.089458264 -0800
@@ -519,7 +519,9 @@
 	    if (__CFStrHasContentsAllocator(str)) {	/* Also apply any preferred size from the allocator; should we do something for  */
                 newCapacity = CFAllocatorGetPreferredSizeForSize(__CFStrContentsAllocator(str), newCapacity, 0);
             } else {
+#if defined(__MACH__)
                 newCapacity = malloc_good_size(newCapacity);
+#endif
             }
             return newCapacity; // If packing: __CFStrUnpackNumber(__CFStrPackNumber(newCapacity));
         }
diff -r -u CF-299.orig/URL.subproj/CFURL.c CF-299/URL.subproj/CFURL.c
--- CF-299.orig/URL.subproj/CFURL.c	2003-10-24 15:23:55.000000000 -0700
+++ CF-299/URL.subproj/CFURL.c	2005-02-24 18:14:44.454775552 -0800
@@ -2080,6 +2080,7 @@
     Boolean baseIsObjC;
 
     CFAssert1(relativeURL != NULL, __kCFLogAssertion, "%s(): Cannot create an absolute URL from a NULL relative URL", __PRETTY_FUNCTION__);
+#if defined(__MACH__)
     if (CF_IS_OBJC(__kCFURLTypeID, relativeURL)) {
         CFURLRef (*absoluteURLMsg)(const void *, SEL) = (void *)__CFSendObjCMsg;
         static SEL s = NULL;  if (!s) s = __CFGetObjCSelector("absoluteURL"); 
@@ -2087,6 +2088,7 @@
         if (anURL) CFRetain(anURL);
         return anURL;
     } 
+#endif
 
     __CFGenericValidateType(relativeURL, __kCFURLTypeID);
 
@@ -2250,6 +2252,7 @@
 
 CFStringRef  CFURLCopyScheme(CFURLRef  anURL) {
     CFStringRef scheme;
+#if defined(__MACH__)
     if (CF_IS_OBJC(__kCFURLTypeID, anURL)) {
         CFStringRef (*schemeMsg)(const void *, SEL) = (void *)__CFSendObjCMsg;
 	static SEL s = NULL;  if (!s) s = __CFGetObjCSelector("scheme"); 
@@ -2257,6 +2260,7 @@
         if (scheme) CFRetain(scheme);
         return scheme;
     } 
+#endif
     if (URL_PATH_TYPE(anURL) != FULL_URL_REPRESENTATION) {
         if (anURL->_base) {
             return CFURLCopyScheme(anURL->_base);
@@ -2484,6 +2488,7 @@
 // For the next four methods, it is important to realize that, if a URL supplies any part of the net location (host, user, port, or password), it must supply all of the net location (i.e. none of it comes from its base URL).  Also, it is impossible for a URL to be relative, supply none of the net location, and still have its (empty) net location take precedence over its base URL (because there's nothing that precedes the net location except the scheme, and if the URL supplied the scheme, it would be absolute, and there would be no base).
 CFStringRef  CFURLCopyHostName(CFURLRef  anURL) {
     CFStringRef tmp;
+#if defined(__MACH__)
     if (CF_IS_OBJC(__kCFURLTypeID, anURL)) {
         CFStringRef (*hostMsg)(const void *, SEL) = (void *)__CFSendObjCMsg;
 	static SEL s = NULL;  if (!s) s = __CFGetObjCSelector("host"); 
@@ -2491,6 +2496,7 @@
         if (tmp) CFRetain(tmp);
         return tmp;
     } 
+#endif
     __CFGenericValidateType(anURL, __kCFURLTypeID);
     if (URL_PATH_TYPE(anURL) != FULL_URL_REPRESENTATION) {
         if (anURL->_base) {
@@ -2520,6 +2526,7 @@
 // Return -1 to indicate no port is specified
 SInt32 CFURLGetPortNumber(CFURLRef  anURL) {
     CFStringRef port;
+#if defined(__MACH__)
     if (CF_IS_OBJC(__kCFURLTypeID, anURL)) {
         CFNumberRef (*portMsg)(const void *, SEL) = (void *)__CFSendObjCMsg;
 	static SEL s = NULL;  if (!s) s = __CFGetObjCSelector("port"); 
@@ -2528,6 +2535,7 @@
         if (cfPort && CFNumberGetValue(cfPort, kCFNumberSInt32Type, &num)) return num;
         return -1;
     } 
+#endif
     __CFGenericValidateType(anURL, __kCFURLTypeID);
     if (URL_PATH_TYPE(anURL) != FULL_URL_REPRESENTATION) {
         if (anURL->_base) {
@@ -2555,6 +2563,7 @@
 
 CFStringRef  CFURLCopyUserName(CFURLRef  anURL) {
     CFStringRef user;
+#if defined(__MACH__)
     if (CF_IS_OBJC(__kCFURLTypeID, anURL)) {
         CFStringRef (*userMsg)(const void *, SEL) = (void *)__CFSendObjCMsg;
 	static SEL s = NULL;  if (!s) s = __CFGetObjCSelector("user"); 
@@ -2562,6 +2571,7 @@
         if (user) CFRetain(user);
         return user;
     } 
+#endif
     __CFGenericValidateType(anURL, __kCFURLTypeID);
     if (URL_PATH_TYPE(anURL) != FULL_URL_REPRESENTATION) {
         if (anURL->_base) {
@@ -2581,6 +2591,7 @@
 
 CFStringRef  CFURLCopyPassword(CFURLRef  anURL) {
     CFStringRef passwd;
+#if defined(__MACH__)
     if (CF_IS_OBJC(__kCFURLTypeID, anURL)) {
         CFStringRef (*passwordMsg)(const void *, SEL) = (void *)__CFSendObjCMsg;
 	static SEL s = NULL;  if (!s) s = __CFGetObjCSelector("password"); 
@@ -2588,6 +2599,7 @@
         if (passwd) CFRetain(passwd);
         return passwd;
     } 
+#endif
     __CFGenericValidateType(anURL, __kCFURLTypeID);
     if (URL_PATH_TYPE(anURL) != FULL_URL_REPRESENTATION) {
         if (anURL->_base) {
@@ -2609,6 +2621,7 @@
 
 static CFStringRef  _unescapedParameterString(CFURLRef  anURL) {
     CFStringRef str;
+#if defined(__MACH__)
     if (CF_IS_OBJC(__kCFURLTypeID, anURL)) {
         CFStringRef (*paramMsg)(const void *, SEL) = (void *)__CFSendObjCMsg;
 	static SEL s = NULL;  if (!s) s = __CFGetObjCSelector("parameterString"); 
@@ -2616,6 +2629,7 @@
         if (str) CFRetain(str);
         return str;
     } 
+#endif
     __CFGenericValidateType(anURL, __kCFURLTypeID);
     if (URL_PATH_TYPE(anURL) != FULL_URL_REPRESENTATION) {
         return NULL;
@@ -2647,6 +2661,7 @@
 
 static CFStringRef  _unescapedQueryString(CFURLRef  anURL) {
     CFStringRef str;
+#if defined(__MACH__)
     if (CF_IS_OBJC(__kCFURLTypeID, anURL)) {
         CFStringRef (*queryMsg)(const void *, SEL) = (void *)__CFSendObjCMsg;
 	static SEL s = NULL;  if (!s) s = __CFGetObjCSelector("query"); 
@@ -2654,6 +2669,7 @@
         if (str) CFRetain(str);
         return str;
     } 
+#endif
     __CFGenericValidateType(anURL, __kCFURLTypeID);
     if (URL_PATH_TYPE(anURL) != FULL_URL_REPRESENTATION) {
         return NULL;
@@ -2685,6 +2701,7 @@
 // Fragments are NEVER taken from a base URL
 static CFStringRef  _unescapedFragment(CFURLRef  anURL) {
     CFStringRef str;
+#if defined(__MACH__)
     if (CF_IS_OBJC(__kCFURLTypeID, anURL)) {
         CFStringRef (*fragmentMsg)(const void *, SEL) = (void *)__CFSendObjCMsg;
 	static SEL s = NULL;  if (!s) s = __CFGetObjCSelector("fragment"); 
@@ -2692,6 +2709,7 @@
         if (str) CFRetain(str);
         return str;
     } 
+#endif
     __CFGenericValidateType(anURL, __kCFURLTypeID);
     if (URL_PATH_TYPE(anURL) != FULL_URL_REPRESENTATION) {
         return NULL;
@@ -3592,6 +3610,7 @@
         }
     }
 
+
     if (relPath == NULL) {
         CFStringRef urlPath = CFURLCopyPath(anURL);
         CFStringEncoding enc = (anURL->_flags & IS_OLD_UTF8_STYLE) ? kCFStringEncodingUTF8 : anURL->_encoding;
